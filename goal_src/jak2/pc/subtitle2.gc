;;-*-Lisp-*-
(in-package goal)

#|

  Code for subtitles for the PC port. A PC actor pool is provided, and the subtitle2 process lives there.
  Jak 2 has subtitles, but only for cutscenes and only for the actual spoken text.
  The subtitle process automatically looks for currently-playing audio in the gui control.
  It looks for specific channels there, NOT including the movie or subtitle channel.

  This updated subtitle system has a few different features than the Jak 1 subtitle system:
  - you can have multiple playing subtitles at once. Additional subtitles are rendered above the older ones,
    just like real subtitles. This goes for both multiple subtitles within the same scene, and also multiple scenes
    playing at once.
  - it can "merge" with the pre-existing subtitle system. Some code in scene.gc is changed to redirect subtitles
    to here to do that.
  - you supply the start AND end times as opposed to just the start time.
  - the speaker names are color-coded.
  Note that subtitle images are NOT supported with this! Merge mode will also NOT work with subtitle images.

  Similarly to the generic text file, only one subtitles text file is loaded at once, stored in a specific
  heap.

 |#


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; constants
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defconstant PC_SUBTITLE_FILE_SIZE (* 192 1024)) ;; 192K heap for subtitles. adjust later if necessary.
(defconstant PC_SUBTITLE_FILE_NAME "subti2")
(defconstant PC_SUBTITLE_QUEUE_SIZE 8) ;; up to 8 things that display subtitles can be detected at once
(defconstant PC_SUBTITLE_QUEUE_MAX_LINES 2) ;; up to 2 lines can be queued per queueable thing
(defconstant PC_SUBTITLE_MAX_LINES 16) ;; max subtitles that can be displayed at once: queue-size * queue-lines

(defconstant PC_SUB_DBG_Y 32)
(defconstant PC_SUB_DBG_CHECK_GROUP_SIZE 22)
(defglobalconstant PC_SUBTITLE_DEBUG #t)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; types and enums
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;------------------------
;;  data
;;;------------------------


(defenum pc-subtitle2-flags
  :bitfield #t
  :type uint16
  (offscreen) ;; speaker is offscreen.
  )

;; the list of available speakers for subtitles
(defenum pc-subtitle2-speaker
  :type uint16
  (none) ;; won't display a speaker - use this for tutorial messages etc.

  (computer)
  (jak)
  (darkjak)
  (daxter)
  (samos)
  (keira)
  (keira-before-class-3)
  (kid)
  (kor)
  (metalkor)
  (baron)
  (errol)
  (torn)
  (tess)
  (guard)
  (guard-a)
  (guard-b)
  (krew)
  (sig)
  (brutter)
  (vin)
  (youngsamos)
  (youngsamos-before-rescue)
  (pecker)
  (onin)
  (ashelin)
  (jinx)
  (mog)
  (grim)
  (agent)
  (citizen-male)
  (citizen-female)
  (oracle)
  (precursor)

  (max))

;; information about a single line of subtitles
(deftype subtitle2-line (structure)
  (
   (start-frame  float)  ;; the first frame to show the line on
   (end-frame    float)  ;; the last frame to show the line on
   (text     string)     ;; the text for the subtitle2 line
   (speaker  pc-subtitle2-speaker) ;; who the line speaker is
   (flags    pc-subtitle2-flags)   ;; flags
   )
  :pack-me
  )

;; an individual entry to a subtitle2 text making up a "scene" (audio file, spool), comprised of a series of lines
(deftype subtitle2-scene (structure)
  (
   ;; the name of the spool-anim or audio file
   (name  string)
   ;; the amount of lines
   (length int32)
   ;; line data
   (lines (inline-array subtitle2-line))


   )
  :pack-me
  :size-assert #xc  ;; compact!

  (:methods
    (get-line-at-pos (_type_ float int) subtitle2-line)
    )
  )

;; the global subtitle2 text info bank
(deftype subtitle2-text-info (basic)
  ((length  int16)
   (version int16)
   (lang    pc-subtitle-lang)
   (speaker-length  int16)
   (speaker-names   (array string))
   (data    subtitle2-scene :inline :dynamic)
   )

  (:methods
    (get-speaker (_type_ pc-subtitle2-speaker) string)
    (get-scene-by-name (_type_ string) subtitle2-scene)
    )
  )


(defmacro subtitle2-flags? (sub &rest flags)
  `(logtest? (-> ,sub flags) (pc-subtitle2-flags ,@flags)))



;;;----------------------------------
;;  process type
;;;----------------------------------


;; graphic parameters for subtitles
(deftype subtitle2-bank (structure)
  (
   (scale float)
   (width float)
   (lines float)
   )
  )

(define *SUBTITLE2-bank*
    (new 'static 'subtitle2-bank
                  :scale 1.0
                  :width 1.0
                  :lines 2.0
                  ))


(deftype subtitle2-queue-element (structure)
  ((id    sound-id)
   (gui   gui-connection)
   (lines subtitle2-line 2)
   )
  
  (:methods
    (clear-line (_type_) int))
  )

;; the subtitle2 process! it lives on the PC actor pool
(deftype subtitle2 (process)
  (
   (font font-context) ;; the font to use for the subtitles.
   (bank-backup subtitle2-bank :inline) ;; debug backup.

   ;; store the gui id of channels with subtitles that we find.
   ;; that way if subtitle B appears above A, it wont move back down
   ;; if A ends before B
   (queue  subtitle2-queue-element  PC_SUBTITLE_QUEUE_SIZE :inline)
   (lines-0  subtitle2-line  PC_SUBTITLE_MAX_LINES)
   (lines-1  subtitle2-line  PC_SUBTITLE_MAX_LINES)
   (line-queue-idx int8)

   ;; debug things
   (checking-lines?  symbol)
   (current-debug-scene  int16)
   (current-debug-line   int16)
   )

  (:methods
    (clear-queue (_type_) int)
    (update-gui-connections (_type_) int)
    (get-empty-queue (_type_) int)
    (gui-queued? (_type_ gui-connection) symbol)
    (get-active-subtitles (_type_) int)
    (subtitle-format (_type_ subtitle2-line) string)
    (draw-subtitles (_type_) int)
    (debug-print-queue (_type_) int)
    )
  (:states
    subtitle2-debug
    subtitle2-debug-checking-lines)
  )




;;;----------------------------------------------
;;  globals
;;;----------------------------------------------


;; the subtitle2 process.
(define *subtitle2* (the (pointer subtitle2) #f))

;; subtitle2 text data
(define *subtitle2-text* (the subtitle2-text-info #f))
(kheap-alloc (define *subtitle2-text-heap* (new 'global 'kheap)) PC_SUBTITLE_FILE_SIZE)

;; speaker color table
(define *subtitle2-speaker-color-table* (the (pointer rgba) (malloc 'global (* (size-of rgba) (pc-subtitle2-speaker max)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  access subtitle heap
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defmethod get-speaker subtitle2-text-info ((obj subtitle2-text-info) (speaker pc-subtitle2-speaker))
  "get the translated string for that speaker"
  (if (and (> speaker (pc-subtitle2-speaker none)) (< speaker (-> obj speaker-length)))
      (-> obj speaker-names speaker)
      (the string #f))
  )

(defmethod get-scene-by-name subtitle2-text-info ((obj subtitle2-text-info) (name string))
  "get a subtitle scene info with the corresponding name. #f = none found"

  ;; invalid name so return invalid scene.
  (if (not name)
      (return (the subtitle2-scene #f)))

  (dotimes (i (length obj))
    ;; name and kind matches, return that!
    (when (string= (-> obj data i name) name)
      (return (-> obj data i)))
    )

  (the subtitle2-scene #f))


(defmethod get-line-at-pos subtitle2-scene ((obj subtitle2-scene) (pos float) (index int))
  "return the subtitle line at that position. #f = none found
   index is which line to return, since you can have multiple lines that cover the same position."
   
  (let ((found 0))

      (dotimes (i (length obj))
        (when (and (>= pos (-> obj lines i start-frame))
                   (< pos (-> obj lines i end-frame)))
          (when (= found index)
            (return (-> obj lines i)))
          (1+! found)
          )))
  
  (the subtitle2-line #f))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  loading files
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun load-subtitle2-text-info ((txt-name string) (curr-text symbol) (heap kheap))
  "load a subtitles text file onto a heap.
   txt-name = file name suffix
   curr-text = a symbol to a subtitle2-text-info to link the file to
   heap = the text heap to load the file onto"

  (let ((heap-sym-heap (the-as subtitle2-text-info (-> curr-text value)))
        (lang (-> *setting-control* user-current subtitle-language))
        (load-status 0)
        (heap-free (&- (-> heap top) (the-as uint (-> heap base)))))

    ;; current text has nothing loaded, or language doesn't match.
    (when (or (= heap-sym-heap #f)
              (!= (-> heap-sym-heap lang) lang))
      ;; so reload.

      ;; reset the text heap.
      (kheap-reset heap)

      ;; try to load load...
      (while (not (str-load (string-format "~D~S.TXT" lang txt-name) -1 (logand -64 (&+ (-> heap current) 63)) (&- (-> heap top) (-> heap current))))
          (return 0)
          )
      ;; load succeeded. check status.

      (label retry)
      (let ((status (str-load-status (the-as (pointer int32) (& load-status)))))
        (when (= status 'error)
          (format 0 "Error loading subtitle2~%")
          (return 0)
          (goto loaded)
          )
        (cond
          ((>= load-status (+ heap-free -300))
           (format 0 "Game subtitle2 heap overrun!~%")
           (return 0)
           )
          ((= status 'busy)
           ;; still loading.
           (goto retry)
           )
          )
        )
      (label loaded)

      ;; link the text file!
      (let ((new-mem (logand -64 (&+ (-> heap current) 63))))
          (flush-cache 0)
          (set! (-> curr-text value) (link new-mem (-> (string-format "~D~S.TXT" lang txt-name) data) load-status heap 0))
          )
      ;; if linking failed just make the text invalid.
      (if (<= (the-as int (-> curr-text value)) 0)
          (set! (-> curr-text value) (the-as object #f))
          )
      ))
  0)

(defun load-level-subtitle2-files ((idx int))
  "Load the subtitle2 files needed for level idx.
   This function made more sense back when text files were split up, but in the end they put everything
   in a single text group and file."

  ;; just load common.
  (if (or *level-text-file-load-flag* (>= idx 0))
      (load-subtitle2-text-info PC_SUBTITLE_FILE_NAME '*subtitle2-text* *subtitle2-text-heap*)
      )

  (none))


(defmacro reload-subtitles ()
  "rebuild and reload subtitles."
  `(begin
      (asm-text-file subtitle2 :files ("game/assets/game_subtitle.gp"))
      (if *subtitle2-text*
          (+! (-> *subtitle2-text* lang) (the-as pc-subtitle-lang 1)))
      (load-level-subtitle2-files 0)))

(defmacro reload-text ()
  "rebuild and reload text."
  `(begin
      (mng)
      (if *common-text*
          (+! (-> *common-text* language-id) 1))
      (load-level-text-files 0)))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  subtitle2 queue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defmethod clear-line subtitle2-queue-element ((obj subtitle2-queue-element))
  "make this queue element invalid"

  (set! (-> obj gui) #f)
  (set! (-> obj id) (new 'static 'sound-id))
  (set! (-> obj lines 0) #f)
  (set! (-> obj lines 1) #f)
  0)

(defmethod clear-queue subtitle2 ((obj subtitle2))
  "mark all slots in the gui queue as available"

  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)
    (clear-line (-> obj queue i)))
  0)

(defmethod update-gui-connections subtitle2 ((obj subtitle2))
  "mark all inactive slots in the gui queue as available"

  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)

    (let ((gui (lookup-gui-connection *gui-control* (the process #f) (gui-channel none) (the string #f) (-> obj queue i id))))
      (if (or (zero? (-> obj queue i id))
              (not gui)
              (!= (gui-action playing) (-> gui action)))
          (clear-line (-> obj queue i)))))
  0)

(defmethod gui-queued? subtitle2 ((obj subtitle2) (gui gui-connection))
  "return #t is the gui is in the queue"

  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)
    (if (= (-> gui id) (-> obj queue i id))
        (return #t)))
  #f)

(defmethod get-empty-queue subtitle2 ((obj subtitle2))
  "return the first available gui queue slot"

  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)
    (if (not (-> obj queue i gui))
        (return i)))
  (format #t "ran out of subtitle queue slots!")
  0
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  subtitle2 process and drawing!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun subtitle-channel? ((ch gui-channel))
  (or (= ch (gui-channel alert))
      (= ch (gui-channel daxter))
      (= ch (gui-channel guard))
      (= ch (gui-channel sig))
      )
  )

(defmethod get-active-subtitles subtitle2 ((obj subtitle2))
  "collect active subtitles and add them to the queue
   if a gui connection is already in the queue,
   it will stay in the same slot when it was first added"

  ;; todo
  (-> *gui-control* engine)
  (let ((current (-> *gui-control* engine alive-list-end prev0)))
    (-> *gui-control* engine)
    (let ((next (-> current prev0)))
      (while (!= current (-> *gui-control* engine alive-list))
        (let ((gui-conn (the gui-connection current)))
          (when (and (subtitle-channel? (-> gui-conn channel))
                     (= (gui-action playing) (-> gui-conn action)))

            (when (not (gui-queued? obj gui-conn))
                (let ((slot (get-empty-queue obj)))
                    (set! (-> obj queue slot id) (-> gui-conn id))
                    (set! (-> obj queue slot gui) gui-conn)
                    )
                )
            )
          )
        (set! current next)
        (-> *gui-control* engine)
        (set! next (-> next prev0))
        )
      )
    )
  0)


(defmethod subtitle-format subtitle2 ((obj subtitle2) (line subtitle2-line))
  "format the string for a subtitle line to *temp-string*"

  (cond
    ((= (pc-subtitle2-speaker none) (-> line speaker))
     ;; there's no speaker so who cares.
     (string-format "~S" (-> line text)))
    ((or (= #t (-> *pc-settings* subtitle-speaker?))
         (and (= 'auto (-> *pc-settings* subtitle-speaker?)) (subtitle2-flags? line offscreen)))
     ;; there is a speaker and we do want it.
     (string-format "~o~S:~0L ~S" (-> *subtitle2-speaker-color-table* (-> line speaker))
                                  (get-speaker *subtitle2-text* (-> line speaker))
                                  (-> line text)))
    (else
     (string-format "~S" (-> line text)))
    )
  *temp-string*)

(defun current-subtitle2-pos ((id sound-id))
  "get the str position for this sound id in a 30/sec measurement"
  (let ((pos (the float (current-str-pos id))))
    (if (< pos 0.0) -1.0 (/ pos (/ 1024.0 30)))))


(defun setup-subtitle2-font ((font font-context))
  "setup a font for the subtitle2 subtitles."

  ;; set font settings.
  (set-origin! font (the int (* (- 1.0 (-> *SUBTITLE2-bank* width)) 256))
                    (the int (* 0.698 416)))
  (set-width! font (the int (* (-> *SUBTITLE2-bank* width) 0.91 512)))
  (set-height! font (the int (* (-> *SUBTITLE2-bank* lines) 44)))
  (set-scale! font (* 0.5 (-> *SUBTITLE2-bank* scale)))
  )


(defmethod draw-subtitles subtitle2 ((self subtitle2))
  "do the subtitle drawing"
  
  ;; set up our font to the initial parameters
  (setup-subtitle2-font (-> self font))

  (if (not *subtitle2-text*)
      (return 0))
  
  ;; check the gui queue for lines to add to the line queue
  (let* ((new-line-queue-idx (mod (1+ (-> self line-queue-idx)) 2))
         (line-queue-old (if (zero? (-> self line-queue-idx)) (-> self lines-0) (-> self lines-1)))
         (line-queue (if (zero? new-line-queue-idx) (-> self lines-0) (-> self lines-1)))
         (find-line (lambda ((queue (pointer subtitle2-line)) (line subtitle2-line))
                        (dotimes (i PC_SUBTITLE_MAX_LINES)
                          (if (= line (-> queue i))
                              (return i)))
                        -1)))
  (set! (-> self line-queue-idx) new-line-queue-idx)
  ;; clear the queue we're writing to first
  (dotimes (i PC_SUBTITLE_MAX_LINES)
    (set! (-> line-queue i) #f))

  ;; do two passes - on the first one we add lines that were already being used,
  ;; on the second pass we add new lines
  (dotimes (q 2)
  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)
    (when (-> self queue i gui)
      (let ((pos (current-subtitle2-pos (-> self queue i id))))
        (when *debug-segment*
            (format *stdcon* "subtitle pos: ~3L~D~0L~%" pos))

        (dotimes (ii PC_SUBTITLE_QUEUE_MAX_LINES)
          (let ((scene (get-scene-by-name *subtitle2-text* (-> self queue i gui name))))
          (when scene
            (awhen (get-line-at-pos scene pos ii)
              (let ((index-in-old (find-line line-queue-old it))
                    (index-empty (find-line line-queue (the subtitle2-line #f))))
                (cond
                  ((and (= q 0) (!= -1 index-in-old))
                    (set! (-> line-queue index-in-old) it))
                  ((= q 1)
                    (set! (-> line-queue index-empty) it))
                  )
                )
              )
            ))
          )
        )
      )
    ))

  (let ((cur-y (-> self font origin y)) ;; the current y for the text
        (last-height 0.0) ;; the height of the previous subtitle
        (lines-done 0)
        )

  (dotimes (i PC_SUBTITLE_QUEUE_MAX_LINES)
    (when (-> line-queue i)

      (subtitle-format self (-> line-queue i))

      ;; push subtitle up since we are not the first one
      (when (nonzero? lines-done)
        ;(-! cur-y (/ last-height 2))
        (-! cur-y (print-game-text *temp-string* (-> self font) #t 44 (bucket-id subtitle)))
        )

      ;; set the current y and draw line
      (set! (-> self font origin y) cur-y)
      (print-game-text *temp-string* (-> self font) #f 44 (bucket-id subtitle))

      ;; save this for later usage
      (set! last-height (print-game-text *temp-string* (-> self font) #t 44 (bucket-id subtitle)))
      (1+! lines-done)
      )
    )))
  0)

(defmethod debug-print-queue subtitle2 ((self subtitle2))
  "print the queue to *stdcon*"
  
  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)
    (if (-> self queue i gui)
        (format *stdcon* "~D: ~D ~`gui-connection`P~%" i (-> self queue i id) (-> self queue i gui))))

  0)

(defstate subtitle2-process (subtitle2)

  :event (behavior ((from process) (argc int) (msg symbol) (block event-message-block))
    (case msg
      (('debug)
       ;(go subtitle2-debug)
       #f)
      )
    )

  :code (behavior ()
    (loop
      (suspend))
    )

  :trans (behavior ()
    ;(load-level-subtitle2-files 0)

    ;; get subtitles
    (update-gui-connections self)
    (get-active-subtitles self)

    (when *debug-segment*
        (when (and (cpad-hold? 0 l3) (cpad-pressed? 0 r3))
            (cpad-clear! 0 start)
            (send-event self 'debug)
            )

        )

    (none))

  :post (behavior ()

    (draw-subtitles self)

    (if (and *debug-segment* PC_SUBTITLE_DEBUG)
        (debug-print-queue self))
    0)

  )




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; helper functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(defmethod length subtitle2-text-info ((obj subtitle2-text-info))
  "Get the length (number of subtitle2 scenes) in a subtitle2-text-info."
  (-> obj length)
  )

(defmethod length subtitle2-scene ((obj subtitle2-scene))
  "Get the length (number of subtitle2 lines) in a subtitle2-scene."
  (-> obj length)
  )


(defbehavior subtitle2-init-by-other subtitle2 ()
  "external initializer for subtitle2 process"

  (set! (-> self font) (new 'process 'font-context *font-default-matrix*
                            0 0 0.0 (font-color default) (font-flags shadow kerning left middle large)))
  (set! (-> self checking-lines?) #f)
  (clear-queue self)
  (dotimes (i PC_SUBTITLE_MAX_LINES)
    (set! (-> self lines-0 i) #f)
    (set! (-> self lines-1 i) #f)
    )

  (go subtitle2-process)
  )


(defun subtitle2-stop ()
  "kill the subtitle2 process"

  (kill-by-type subtitle2 *display-pool*)
  (set! *subtitle2* (the (pointer subtitle2) #f)))

(defun subtitle2-start ()
  "start the subtitle2 process"

  (when *subtitle2*
    (subtitle2-stop)
    )

  (set! *subtitle2* (process-spawn subtitle2 :from *pc-dead-pool* :to *display-pool*))
  )


(defun set-subtitle-speaker-colors ()
  "fill the subtitle speaker color table"

  (dotimes (i (pc-subtitle2-speaker max))
    (set! (-> *subtitle2-speaker-color-table* i) (-> *font-work* color-table (font-color red) color 0))
    )
  
  (set! (-> *subtitle2-speaker-color-table* (pc-subtitle2-speaker baron)) (static-rgba #xff #x00 #x00 #x80))
  (set! (-> *subtitle2-speaker-color-table* (pc-subtitle2-speaker samos)) (static-rgba #x00 #xff #x00 #x80))
  (set! (-> *subtitle2-speaker-color-table* (pc-subtitle2-speaker kor)) (static-rgba #x00 #x00 #xff #x80))
  )

;; fill the subtitle speaker table
(set-subtitle-speaker-colors)

;; start the subtitle2 process when this file loads.
(subtitle2-start)



